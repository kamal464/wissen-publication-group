name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy-to-ec2:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          set -e
          echo "üîß Setting up SSH..."
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Check if SSH key secret is set
          if [ -z "${{ secrets.EC2_SSH_PRIVATE_KEY }}" ]; then
            echo "‚ùå EC2_SSH_PRIVATE_KEY secret is not set"
            exit 1
          fi
          
          # Check if EC2_HOST secret is set
          if [ -z "${{ secrets.EC2_HOST }}" ]; then
            echo "‚ùå EC2_HOST secret is not set"
            exit 1
          fi
          
          # Write SSH key
          printf '%s\n' "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          sed -i 's/\r$//' ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          
          # Verify SSH key file
          if [ ! -s ~/.ssh/id_rsa ]; then
            echo "‚ùå SSH key file is empty"
            exit 1
          fi
          
          # Check SSH key format (more lenient check)
          if ! grep -qE "(BEGIN|PRIVATE|KEY)" ~/.ssh/id_rsa; then
            echo "‚ùå Invalid SSH key format - key file does not contain expected markers"
            echo "First 50 characters of key file:"
            head -c 50 ~/.ssh/id_rsa || true
            exit 1
          fi
          
          # Add host to known_hosts
          echo "üîç Adding EC2 host to known_hosts..."
          ssh-keyscan -H "${{ secrets.EC2_HOST }}" >> ~/.ssh/known_hosts 2>&1 || {
            echo "‚ö†Ô∏è  ssh-keyscan failed, but continuing..."
          }
          chmod 644 ~/.ssh/known_hosts
          
          echo "‚úÖ SSH setup complete"

      - name: Test SSH Connection
        run: |
          echo "üîç Testing SSH connection to EC2..."
          EC2_HOST_RAW="${{ secrets.EC2_HOST }}"
          
          # Validate and sanitize EC2_HOST
          if [ -z "$EC2_HOST_RAW" ]; then
            echo "‚ùå EC2_HOST secret is not set or is empty"
            echo "Please set EC2_HOST in GitHub Secrets with your EC2 instance's public IP or hostname"
            exit 1
          fi
          
          # Show raw value length and first/last characters (for debugging without exposing full value)
          echo "Raw EC2_HOST length: ${#EC2_HOST_RAW} characters"
          echo "First 3 chars: ${EC2_HOST_RAW:0:3}"
          echo "Last 3 chars: ${EC2_HOST_RAW: -3}"
          
          # Remove all whitespace, newlines, and common invalid characters
          EC2_HOST=$(echo "$EC2_HOST_RAW" | tr -d '\n\r\t ' | sed 's/[^a-zA-Z0-9.-]//g')
          
          # Remove http:// or https:// if present
          EC2_HOST=$(echo "$EC2_HOST" | sed 's|^https\?://||' | sed 's|/.*$||')
          
          # Remove trailing dots or slashes
          EC2_HOST=$(echo "$EC2_HOST" | sed 's/[./]*$//')
          
          if [ -z "$EC2_HOST" ]; then
            echo "‚ùå EC2_HOST secret appears to be empty after sanitization"
            echo "Raw value (first 20 chars): ${EC2_HOST_RAW:0:20}"
            exit 1
          fi
          
          # Validate format (should be IP or hostname)
          if echo "$EC2_HOST" | grep -qE '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$'; then
            echo "‚úÖ EC2_HOST appears to be a valid IP address"
          elif echo "$EC2_HOST" | grep -qE '^[a-zA-Z0-9][a-zA-Z0-9.-]*[a-zA-Z0-9]$|^[a-zA-Z0-9]$'; then
            echo "‚úÖ EC2_HOST appears to be a valid hostname"
          else
            echo "‚ö†Ô∏è  Warning: EC2_HOST format may be invalid after sanitization"
            echo "Sanitized value: [$EC2_HOST]"
            echo "Expected: IP address (e.g., 54.165.116.208) or hostname (e.g., ec2-54-165-116-208.compute-1.amazonaws.com)"
          fi
          
          echo "Using sanitized EC2_HOST: [$EC2_HOST]"
          echo "Hostname length: ${#EC2_HOST} characters"
          
          # Export for use in deployment step
          echo "EC2_HOST=$EC2_HOST" >> $GITHUB_ENV
          
          if ssh -o StrictHostKeyChecking=no \
                 -o ConnectTimeout=10 \
                 -o ServerAliveInterval=5 \
                 -o ServerAliveCountMax=3 \
                 -o BatchMode=yes \
                 ubuntu@"$EC2_HOST" \
                 "echo '‚úÖ SSH connection successful'; hostname; uptime" 2>&1; then
            echo "‚úÖ SSH connection test passed"
          else
            SSH_EXIT_CODE=$?
            echo "‚ùå SSH connection test failed (exit code: $SSH_EXIT_CODE)"
            echo ""
            echo "Sanitized EC2_HOST value: [$EC2_HOST]"
            echo ""
            echo "Please check:"
            echo "  1. EC2 instance is running (not stopped/terminated)"
            echo "  2. EC2_HOST secret should contain ONLY the IP address or hostname"
            echo "     Examples:"
            echo "       ‚úÖ 54.165.116.208"
            echo "       ‚úÖ ec2-54-165-116-208.compute-1.amazonaws.com"
            echo "       ‚ùå http://54.165.116.208"
            echo "       ‚ùå 54.165.116.208:22"
            echo "       ‚ùå ssh://ubuntu@54.165.116.208"
            echo "  3. Security group allows SSH (port 22) from GitHub Actions IPs"
            echo "  4. EC2 instance has a public IP address"
            echo ""
            echo "Attempting to ping the host..."
            ping -c 3 "$EC2_HOST" 2>&1 || echo "Ping also failed"
            exit 1
          fi

      - name: Deploy to EC2
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          EC2_HOST: ${{ env.EC2_HOST }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          CLOUDFRONT_URL: ${{ secrets.CLOUDFRONT_URL }}
        run: |
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=30 \
              -o ConnectTimeout=30 \
              -o TCPKeepAlive=yes \
              -o BatchMode=yes \
              ubuntu@${EC2_HOST} bash -s << ENDSSH
            export DB_PASSWORD="$DB_PASSWORD"
            export EC2_HOST="$EC2_HOST"
            export AWS_REGION="$AWS_REGION"
            export AWS_ACCESS_KEY_ID="$AWS_ACCESS_KEY_ID"
            export AWS_SECRET_ACCESS_KEY="$AWS_SECRET_ACCESS_KEY"
            export S3_BUCKET_NAME="$S3_BUCKET_NAME"
            export CLOUDFRONT_URL="$CLOUDFRONT_URL"
            set -x
            
            # Ensure PM2 is in PATH
            export PATH="$PATH:/usr/bin:/usr/local/bin:$HOME/.local/bin"
            
            # Verify PM2 is available
            if ! command -v pm2 >/dev/null 2>&1; then
              echo "‚ö†Ô∏è  PM2 not found in PATH, trying to locate it..."
              if [ -f "$HOME/.nvm/nvm.sh" ]; then
                source "$HOME/.nvm/nvm.sh"
              fi
              if ! command -v pm2 >/dev/null 2>&1; then
                echo "‚ùå PM2 is not installed. Installing PM2..."
                npm install -g pm2 || {
                  echo "‚ùå Failed to install PM2"
                  exit 1
                }
              fi
            fi
            echo "‚úÖ PM2 found: $(which pm2)"
            pm2 --version || true
            
            cd /var/www/wissen-publication-group || { echo "‚ùå Directory not found"; exit 1; }
            
            echo "=========================================="
            echo "üöÄ STARTING DEPLOYMENT"
            echo "=========================================="
            
            pm2 delete all 2>/dev/null || true
            sleep 2
            
            echo "üì• Pulling latest code..."
            git fetch origin
            git reset --hard origin/main
            git clean -fd
            NEW_COMMIT=$(git rev-parse --short HEAD)
            echo "üìå Deployed commit: $NEW_COMMIT"
            
            # URL encode the password to handle special characters
            DB_PASSWORD_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${DB_PASSWORD}', safe=''))" 2>/dev/null || echo "${DB_PASSWORD}")
            
            {
              echo "DATABASE_URL=postgresql://postgres:${DB_PASSWORD_ENCODED}@localhost:5432/wissen_publication_group"
              echo "NODE_ENV=production"
              echo "PORT=3001"
              echo "CORS_ORIGIN=http://${EC2_HOST},http://localhost:3000,http://localhost:3002"
              echo "AWS_REGION=${AWS_REGION}"
              echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"
              echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}"
              echo "S3_BUCKET_NAME=${S3_BUCKET_NAME}"
              echo "CLOUDFRONT_URL=${CLOUDFRONT_URL}"
            } > backend/.env
            
            echo "‚úÖ Created backend/.env file"
            echo "üìù Verifying database connection string (password hidden)..."
            grep -v "PASSWORD" backend/.env | head -1 || true
            
            # Ensure EC2_HOST is set
            if [ -z "${EC2_HOST}" ]; then
              echo "‚ùå EC2_HOST is not set!"
              echo "Current EC2_HOST value: '${EC2_HOST}'"
              exit 1
            fi
            
            echo "Setting frontend environment variables..."
            echo "EC2_HOST=${EC2_HOST}"
            {
              echo "NEXT_PUBLIC_API_URL=http://${EC2_HOST}/api"
              echo "NEXT_PUBLIC_BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
            } > frontend/.env.production
            
            echo "Frontend .env.production contents:"
            cat frontend/.env.production
            echo ""
            
            echo "üî® Building backend..."
            cd backend
            
            # Install dependencies
            echo "Installing backend dependencies..."
            echo "This may take a few minutes - keeping connection alive..."
            
            # Fix permissions for node_modules if it exists
            if [ -d "node_modules" ]; then
              echo "Fixing permissions on existing node_modules..."
              chmod -R u+w node_modules 2>/dev/null || true
            fi
            
            # Try npm ci with unsafe-perm flag for native modules
            if ! timeout 600 npm ci --unsafe-perm; then
              echo "‚ö†Ô∏è  npm ci timed out or failed, trying npm install with unsafe-perm..."
              # Clean and retry with proper permissions
              rm -rf node_modules package-lock.json 2>/dev/null || true
              if ! timeout 600 npm install --unsafe-perm; then
                echo "‚ùå npm install also failed or timed out"
                echo "Checking npm and node versions..."
                npm --version
                node --version
                exit 1
              fi
            fi
            
            # Ensure node_modules has correct permissions
            chmod -R u+w node_modules 2>/dev/null || true
            echo "‚úÖ Backend dependencies installed"
            
            # Verify nest CLI is available
            if ! command -v nest &> /dev/null && ! npx nest --version &> /dev/null; then
              echo "‚ö†Ô∏è  nest CLI not found, checking node_modules..."
              if [ ! -f "node_modules/.bin/nest" ]; then
                echo "‚ùå nest CLI not installed"
                echo "Reinstalling dependencies..."
                rm -rf node_modules package-lock.json
                npm install
              fi
            fi
            
            echo "Generating Prisma client..."
            npx prisma generate || {
              echo "‚ùå Prisma generate failed"
              exit 1
            }
            
            echo "Pushing database schema..."
            npx prisma db push --accept-data-loss || true
            
            echo "Building backend..."
            rm -rf dist
            if ! npm run build; then
              echo "‚ùå Backend build failed"
              echo "Checking if nest is available:"
              which nest || npx nest --version || echo "nest not found"
              echo "Node version: $(node --version)"
              echo "NPM version: $(npm --version)"
              exit 1
            fi
            
            if [ ! -f "dist/src/main.js" ]; then
              echo "‚ùå Backend build file not found"
              echo "Checking dist directory:"
              ls -la dist/ 2>/dev/null || echo "dist directory not found"
              exit 1
            fi
            
            echo "‚úÖ Backend build successful"
            cd ..
            
            echo "üî® Building frontend..."
            cd frontend
            echo "Installing frontend dependencies (this may take a few minutes)..."
            
            # Fix permissions for node_modules if it exists
            if [ -d "node_modules" ]; then
              echo "Fixing permissions on existing node_modules..."
              chmod -R u+w node_modules 2>/dev/null || true
            fi
            
            # Try npm ci with unsafe-perm flag for native modules
            if ! timeout 600 npm ci --unsafe-perm; then
              echo "‚ö†Ô∏è  Frontend npm ci timed out or failed, trying npm install with unsafe-perm..."
              # Clean and retry with proper permissions
              rm -rf node_modules package-lock.json 2>/dev/null || true
              if ! timeout 600 npm install --unsafe-perm; then
                echo "‚ùå Frontend npm install also failed or timed out"
                echo "Checking npm and node versions..."
                npm --version
                node --version
                exit 1
              fi
            fi
            
            # Ensure node_modules has correct permissions
            chmod -R u+w node_modules 2>/dev/null || true
            echo "‚úÖ Frontend dependencies installed"
            rm -rf .next node_modules/.cache .swc
            echo "üìù Building with API URL: http://${EC2_HOST}/api"
            echo "üìù Build time: $NEXT_PUBLIC_BUILD_TIME"
            if ! NEXT_PUBLIC_API_URL="http://${EC2_HOST}/api" NEXT_PUBLIC_BUILD_TIME="$NEXT_PUBLIC_BUILD_TIME" npm run build; then
              echo "‚ùå Frontend build failed - checking logs..."
              echo "Node version: $(node --version)"
              echo "NPM version: $(npm --version)"
              echo "Checking for build errors..."
              exit 1
            fi
            if [ ! -d ".next" ]; then
              echo "‚ùå Frontend build directory not found after build"
              ls -la .next 2>/dev/null || echo "No .next directory"
              exit 1
            fi
            echo "‚úÖ Frontend build successful"
            cd ..
            
            echo "üöÄ Starting services..."
            mkdir -p logs
            
            # Stop all existing PM2 processes
            pm2 delete all 2>/dev/null || true
            sleep 3
            
            # Start services using ecosystem.config.js for better reliability
            echo "Starting services with PM2 ecosystem config..."
            pm2 start ecosystem.config.js || {
              echo "‚ùå PM2 start failed"
              pm2 list || true
              pm2 logs --lines 30 --nostream || true
              exit 1
            }
            
            pm2 save
            
            # Give services time to start
            echo "‚è≥ Waiting for services to initialize..."
            sleep 20
            
            echo "üîç Verifying services..."
            pm2 list
            echo ""
            
            # Verify backend
            BACKEND_STATUS=$(pm2 list | grep wissen-backend | awk '{print $10}' 2>/dev/null || echo "unknown")
            BACKEND_STATUS=${BACKEND_STATUS:-unknown}
            echo "Backend PM2 status: $BACKEND_STATUS"
            
            if [ "$BACKEND_STATUS" != "online" ]; then
              echo "‚ö†Ô∏è  Backend PM2 status is $BACKEND_STATUS"
              echo "Backend logs:"
              pm2 logs wissen-backend --lines 50 --nostream || true
              echo ""
            fi
            
            # Verify frontend - this is critical
            FRONTEND_STATUS=$(pm2 list | grep wissen-frontend | awk '{print $10}' 2>/dev/null || echo "unknown")
            FRONTEND_STATUS=${FRONTEND_STATUS:-unknown}
            echo "Frontend PM2 status: $FRONTEND_STATUS"
            
            if [ "$FRONTEND_STATUS" != "online" ]; then
              echo "‚ö†Ô∏è  Frontend PM2 status is $FRONTEND_STATUS"
              echo "Frontend logs (last 50 lines):"
              pm2 logs wissen-frontend --lines 50 --nostream || true
              echo ""
              echo "Frontend .env.production:"
              cat frontend/.env.production 2>/dev/null || echo "No .env.production file"
              echo ""
            fi
            
            # Check ports - this is the real test
            # Use ss if available, fallback to netstat
            if command -v ss >/dev/null 2>&1; then
              BACKEND_PORT_COUNT=$(ss -tln 2>/dev/null | grep -c ":3001 " 2>/dev/null || echo "0")
              FRONTEND_PORT_COUNT=$(ss -tln 2>/dev/null | grep -c ":3000 " 2>/dev/null || echo "0")
            else
              BACKEND_PORT_COUNT=$(netstat -tln 2>/dev/null | grep -c ":3001 " 2>/dev/null || echo "0")
              FRONTEND_PORT_COUNT=$(netstat -tln 2>/dev/null | grep -c ":3000 " 2>/dev/null || echo "0")
            fi
            
            # Ensure variables are numbers, default to 0 if empty
            BACKEND_PORT_NUM=${BACKEND_PORT_COUNT:-0}
            FRONTEND_PORT_NUM=${FRONTEND_PORT_COUNT:-0}
            
            # Convert to integer, default to 0 (handle empty strings)
            if [ -z "$BACKEND_PORT_NUM" ]; then
              BACKEND_PORT_NUM=0
            fi
            if [ -z "$FRONTEND_PORT_NUM" ]; then
              FRONTEND_PORT_NUM=0
            fi
            BACKEND_PORT_NUM=$((BACKEND_PORT_NUM + 0))
            FRONTEND_PORT_NUM=$((FRONTEND_PORT_NUM + 0))
            
            echo "Port verification:"
            if [ "${BACKEND_PORT_NUM:-0}" -gt 0 ] 2>/dev/null; then
              echo "  Backend port 3001: ‚úÖ Listening"
            else
              echo "  Backend port 3001: ‚ùå Not listening"
            fi
            if [ "${FRONTEND_PORT_NUM:-0}" -gt 0 ] 2>/dev/null; then
              echo "  Frontend port 3000: ‚úÖ Listening"
            else
              echo "  Frontend port 3000: ‚ùå Not listening"
            fi
            echo ""
            
            if [ "${BACKEND_PORT_NUM:-0}" -eq 0 ] 2>/dev/null; then
              echo "‚ö†Ô∏è  Backend not listening on port 3001 yet"
              echo "Checking if backend process is running..."
              if pgrep -f "dist/src/main.js" > /dev/null; then
                echo "‚úÖ Backend process is running, port may be starting..."
                echo "Waiting 10 more seconds for port to open..."
                sleep 10
                if command -v ss >/dev/null 2>&1; then
                  BACKEND_PORT_RETRY=$(ss -tln 2>/dev/null | grep -c ":3001 " 2>/dev/null || echo "0")
                else
                  BACKEND_PORT_RETRY=$(netstat -tln 2>/dev/null | grep -c ":3001 " 2>/dev/null || echo "0")
                fi
                if [ -z "$BACKEND_PORT_RETRY" ]; then
                  BACKEND_PORT_RETRY=0
                fi
                BACKEND_PORT_RETRY=$((BACKEND_PORT_RETRY + 0))
                if [ "${BACKEND_PORT_RETRY:-0}" -eq 0 ] 2>/dev/null; then
                  echo "‚ùå Backend still not listening after retry"
                  pm2 logs wissen-backend --lines 50 --nostream || true
                  exit 1
                else
                  echo "‚úÖ Backend is now listening on port 3001"
                  BACKEND_PORT_NUM=1
                fi
              else
                echo "‚ùå Backend process not running"
                pm2 logs wissen-backend --lines 50 --nostream || true
                exit 1
              fi
            fi
            
            if [ "${FRONTEND_PORT_NUM:-0}" -eq 0 ] 2>/dev/null; then
              echo "‚ùå Frontend not listening on port 3000 - this is causing the 502 error!"
              echo ""
              echo "=== PM2 Status ==="
              pm2 list || true
              echo ""
              echo "=== Frontend PM2 Info ==="
              pm2 describe wissen-frontend || true
              echo ""
              echo "=== Full Frontend Logs ==="
              pm2 logs wissen-frontend --lines 100 --nostream || true
              echo ""
              echo "=== Frontend Process Check ==="
              ps aux | grep -E "next|node.*frontend" | grep -v grep || echo "No frontend processes found"
              echo ""
              echo "=== Frontend Directory Check ==="
              ls -la frontend/.next 2>/dev/null || echo ".next directory not found"
              echo ""
              echo "=== Checking if frontend build exists ==="
              if [ ! -d "frontend/.next" ]; then
                echo "‚ùå Frontend .next directory not found - build failed!"
                echo "Cannot start frontend without a build"
                echo "Listing frontend directory:"
                ls -la frontend/ | head -20
                exit 1
              fi
              echo "‚úÖ Frontend build exists"
              
              echo "=== Attempting to restart frontend ==="
              pm2 delete wissen-frontend 2>/dev/null || true
              sleep 2
              cd frontend
              if ! pm2 start npm --name wissen-frontend -- start; then
                echo "‚ùå Failed to start frontend with PM2"
                echo "Frontend logs:"
                pm2 logs wissen-frontend --lines 30 --nostream || true
                echo "Trying direct start..."
                NODE_ENV=production PORT=3000 npm start &
                sleep 15
                FRONTEND_PORT_DIRECT=$(netstat -tln 2>/dev/null | grep -c ":3000 " 2>/dev/null || echo "0")
                FRONTEND_PORT_DIRECT=$((FRONTEND_PORT_DIRECT + 0))
                if [ "${FRONTEND_PORT_DIRECT:-0}" -eq 0 ] 2>/dev/null; then
                  echo "‚ùå Direct start also failed"
                  exit 1
                else
                  echo "‚úÖ Frontend started directly"
                  FRONTEND_PORT_NUM=1
                fi
              else
                echo "‚úÖ Frontend started with PM2, waiting for port..."
                cd ..
                sleep 25
                if command -v ss >/dev/null 2>&1; then
                  FRONTEND_PORT_RETRY_CHECK=$(ss -tln 2>/dev/null | grep -c ":3000 " 2>/dev/null || echo "0")
                else
                  FRONTEND_PORT_RETRY_CHECK=$(netstat -tln 2>/dev/null | grep -c ":3000 " 2>/dev/null || echo "0")
                fi
                if [ -z "$FRONTEND_PORT_RETRY_CHECK" ]; then
                  FRONTEND_PORT_RETRY_CHECK=0
                fi
                FRONTEND_PORT_RETRY_NUM=$((FRONTEND_PORT_RETRY_CHECK + 0))
                if [ "${FRONTEND_PORT_RETRY_NUM:-0}" -eq 0 ] 2>/dev/null; then
                  echo "‚ùå Frontend still not listening after restart"
                  echo "=== Final Diagnostics ==="
                  pm2 list || true
                  echo ""
                  echo "=== Frontend Logs ==="
                  pm2 logs wissen-frontend --lines 100 --nostream || true
                  echo ""
                  echo "=== Port Status ==="
                  netstat -tln | grep -E ":3000|:3001" || echo "No services listening"
                  echo ""
                  echo "‚ùå DEPLOYMENT FAILED - Frontend not running"
                  exit 1
                else
                  echo "‚úÖ Frontend is now listening on port 3000"
                  FRONTEND_PORT_NUM=1
                fi
              fi
              if [ "$(pwd)" != "/var/www/wissen-publication-group" ]; then
                cd /var/www/wissen-publication-group
              fi
            fi
            
            echo "üîç Testing health endpoints (with retries)..."
            BACKEND_HEALTH="000"
            FRONTEND_HEALTH="000"
            
            for i in 1 2 3 4 5; do
              echo "Attempt $i/5: Checking backend health..."
              BACKEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/health 2>/dev/null || echo "000")
              if [ "$BACKEND_HEALTH" = "200" ]; then
                echo "‚úÖ Backend health check passed!"
                break
              fi
              sleep 5
            done
            
            for i in 1 2 3 4 5; do
              echo "Attempt $i/5: Checking frontend health..."
              FRONTEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null || echo "000")
              if [ "$FRONTEND_HEALTH" = "200" ]; then
                echo "‚úÖ Frontend health check passed!"
                break
              fi
              sleep 5
            done
            
            echo "Backend health: HTTP $BACKEND_HEALTH"
            echo "Frontend health: HTTP $FRONTEND_HEALTH"
            
            if [ "$BACKEND_HEALTH" != "200" ]; then
              echo "‚ö†Ô∏è  Backend health check returned $BACKEND_HEALTH (may still be starting)"
              echo "Backend logs:"
              pm2 logs wissen-backend --lines 20 --nostream || true
              echo "‚ö†Ô∏è  Continuing deployment - backend may need more time to start"
            fi
            
            if [ "$FRONTEND_HEALTH" != "200" ]; then
              echo "‚ö†Ô∏è  Frontend health check returned $FRONTEND_HEALTH (may still be starting)"
              echo "Frontend logs:"
              pm2 logs wissen-frontend --lines 20 --nostream || true
              echo "‚ö†Ô∏è  Continuing deployment - frontend may need more time to start"
            fi
            
            echo "üîç Verifying services are running before configuring Nginx..."
            echo "Waiting for services to be ready..."
            sleep 10
            
            # Wait for backend to be ready (max 60 seconds)
            BACKEND_READY=0
            for i in {1..12}; do
              BACKEND_RUNNING=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/health 2>/dev/null || echo "000")
              if [ "$BACKEND_RUNNING" = "200" ]; then
                echo "‚úÖ Backend is ready (HTTP $BACKEND_RUNNING)"
                BACKEND_READY=1
                break
              fi
              echo "   Attempt $i/12: Backend not ready yet (HTTP $BACKEND_RUNNING), waiting..."
              sleep 5
            done
            
            # Wait for frontend to be ready (max 60 seconds)
            FRONTEND_READY=0
            for i in {1..12}; do
              FRONTEND_RUNNING=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null || echo "000")
              if [ "$FRONTEND_RUNNING" = "200" ]; then
                echo "‚úÖ Frontend is ready (HTTP $FRONTEND_RUNNING)"
                FRONTEND_READY=1
                break
              fi
              echo "   Attempt $i/12: Frontend not ready yet (HTTP $FRONTEND_RUNNING), waiting..."
              sleep 5
            done
            
            if [ "$BACKEND_READY" -eq 0 ]; then
              echo "‚ùå Backend failed to start after 60 seconds"
              echo "PM2 status:"
              pm2 list || true
              echo "Backend logs:"
              pm2 logs wissen-backend --lines 30 --nostream || true
              echo "Checking if port 3001 is listening:"
              netstat -tln | grep ":3001" || echo "Port 3001 not listening"
              echo "‚ö†Ô∏è  Continuing anyway - backend may start later"
            fi
            
            if [ "$FRONTEND_READY" -eq 0 ]; then
              echo "‚ùå Frontend failed to start after 60 seconds"
              echo "Frontend logs:"
              pm2 logs wissen-frontend --lines 30 --nostream || true
              echo "Checking if port 3000 is listening:"
              netstat -tln | grep ":3000" || echo "Port 3000 not listening"
              echo "‚ö†Ô∏è  Continuing anyway - frontend may start later"
            fi
            
            echo "üîß Configuring Nginx..."
            # Copy the nginx config file from the repo
            if [ -f "nginx-production.conf" ]; then
              sudo cp nginx-production.conf /etc/nginx/sites-available/wissen-publication-group
              echo "‚úÖ Copied nginx-production.conf"
            else
              echo "‚ö†Ô∏è  nginx-production.conf not found, using fallback method"
              # Fallback: use the existing nginx-wissen.conf if available
              if [ -f "nginx-wissen.conf" ]; then
                sudo cp nginx-wissen.conf /etc/nginx/sites-available/wissen-publication-group
                sudo sed -i 's/YOUR_EC2_IP/_/g' /etc/nginx/sites-available/wissen-publication-group
                sudo sed -i 's/api.yourdomain.com/_/g' /etc/nginx/sites-available/wissen-publication-group
                sudo sed -i 's/yourdomain.com/_/g' /etc/nginx/sites-available/wissen-publication-group
                sudo sed -i 's/www.yourdomain.com/_/g' /etc/nginx/sites-available/wissen-publication-group
              else
                echo "‚ùå No nginx config file found!"
                exit 1
              fi
            fi
            
            sudo ln -sf /etc/nginx/sites-available/wissen-publication-group /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
            
            if sudo nginx -t; then
              sudo systemctl reload nginx || sudo systemctl restart nginx
              echo "‚úÖ Nginx configured and reloaded"
              echo "Nginx status:"
              sudo systemctl status nginx --no-pager | head -5 || true
            else
              echo "‚ùå Nginx configuration test failed"
              sudo nginx -t
              echo "Nginx error log (last 10 lines):"
              sudo tail -10 /var/log/nginx/error.log || true
              exit 1
            fi
            
            echo "üîç Final verification - testing Nginx proxy..."
            sleep 3
            NGINX_BACKEND=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/health 2>/dev/null || echo "000")
            NGINX_FRONTEND=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/ 2>/dev/null || echo "000")
            echo "Nginx proxy to backend (/health): HTTP $NGINX_BACKEND"
            echo "Nginx proxy to frontend (/): HTTP $NGINX_FRONTEND"
            
            # Final verification - both services must be listening AND responding
            echo "üîç Final verification - checking ports and HTTP responses..."
            if command -v ss >/dev/null 2>&1; then
              FINAL_BACKEND_PORT=$(ss -tln 2>/dev/null | grep -c ":3001 " 2>/dev/null || echo "0")
              FINAL_FRONTEND_PORT=$(ss -tln 2>/dev/null | grep -c ":3000 " 2>/dev/null || echo "0")
            else
              FINAL_BACKEND_PORT=$(netstat -tln 2>/dev/null | grep -c ":3001 " 2>/dev/null || echo "0")
              FINAL_FRONTEND_PORT=$(netstat -tln 2>/dev/null | grep -c ":3000 " 2>/dev/null || echo "0")
            fi
            
            # Ensure variables are numbers
            if [ -z "$FINAL_BACKEND_PORT" ]; then
              FINAL_BACKEND_PORT=0
            fi
            if [ -z "$FINAL_FRONTEND_PORT" ]; then
              FINAL_FRONTEND_PORT=0
            fi
            FINAL_BACKEND_PORT=$((FINAL_BACKEND_PORT + 0))
            FINAL_FRONTEND_PORT=$((FINAL_FRONTEND_PORT + 0))
            
            # Test HTTP responses, not just ports
            FINAL_BACKEND_HTTP=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://localhost:3001/health 2>/dev/null || echo "000")
            FINAL_FRONTEND_HTTP=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 http://localhost:3000 2>/dev/null || echo "000")
            
            FINAL_BACKEND_HTTP=${FINAL_BACKEND_HTTP:-000}
            FINAL_FRONTEND_HTTP=${FINAL_FRONTEND_HTTP:-000}
            
            echo "Port checks:"
            if [ "${FINAL_BACKEND_PORT:-0}" -gt 0 ] 2>/dev/null; then
              echo "  Backend port 3001: ‚úÖ Listening"
            else
              echo "  Backend port 3001: ‚ùå Not listening"
            fi
            if [ "${FINAL_FRONTEND_PORT:-0}" -gt 0 ] 2>/dev/null; then
              echo "  Frontend port 3000: ‚úÖ Listening"
            else
              echo "  Frontend port 3000: ‚ùå Not listening"
            fi
            echo ""
            echo "HTTP response checks:"
            echo "  Backend HTTP: $FINAL_BACKEND_HTTP"
            echo "  Frontend HTTP: $FINAL_FRONTEND_HTTP"
            echo ""
            
            if [ "${FINAL_BACKEND_PORT:-0}" -eq 0 ] 2>/dev/null || [ "${FINAL_FRONTEND_PORT:-0}" -eq 0 ] 2>/dev/null; then
              echo "‚ùå DEPLOYMENT FAILED - Services not listening on ports!"
              if [ "${FINAL_BACKEND_PORT:-0}" -gt 0 ] 2>/dev/null; then
                echo "Backend port 3001: ‚úÖ"
              else
                echo "Backend port 3001: ‚ùå"
              fi
              if [ "${FINAL_FRONTEND_PORT:-0}" -gt 0 ] 2>/dev/null; then
                echo "Frontend port 3000: ‚úÖ"
              else
                echo "Frontend port 3000: ‚ùå"
              fi
              echo ""
              echo "=== Final PM2 Status ==="
              pm2 list || true
              echo ""
              echo "=== Final Port Status ==="
              netstat -tln | grep -E ":3000|:3001" || echo "No services listening"
              echo ""
              if [ "$FINAL_FRONTEND_PORT" -eq "0" ]; then
                echo "=== Frontend Logs (Final) ==="
                pm2 logs wissen-frontend --lines 100 --nostream || true
              fi
              if [ "$FINAL_BACKEND_PORT" -eq "0" ]; then
                echo "=== Backend Logs (Final) ==="
                pm2 logs wissen-backend --lines 100 --nostream || true
              fi
              exit 1
            fi
            
            # Ports are listening, but check if they're actually responding
            if [ "$FINAL_FRONTEND_HTTP" = "000" ] || [ "$FINAL_FRONTEND_HTTP" = "" ]; then
              echo "‚ö†Ô∏è  Frontend port is listening but not responding to HTTP requests"
              echo "This could mean the service is crashing or not fully started"
              echo ""
              echo "=== Frontend Process Check ==="
              ps aux | grep -E "next|node.*3000" | grep -v grep || echo "No frontend processes found"
              echo ""
              echo "=== Frontend Logs (Recent) ==="
              pm2 logs wissen-frontend --lines 50 --nostream || true
              echo ""
              echo "=== Testing frontend connection ==="
              timeout 3 curl -v http://localhost:3000 2>&1 | head -20 || echo "Connection failed"
              echo ""
              echo "‚ùå Frontend is not responding - DEPLOYMENT FAILED"
              exit 1
            fi
            
            if [ "$FINAL_BACKEND_HTTP" = "000" ] || [ "$FINAL_BACKEND_HTTP" = "" ]; then
              echo "‚ö†Ô∏è  Backend port is listening but not responding to HTTP requests"
              echo "=== Backend Logs (Recent) ==="
              pm2 logs wissen-backend --lines 50 --nostream || true
              echo ""
              echo "‚ùå Backend is not responding - DEPLOYMENT FAILED"
              exit 1
            fi
            
            if [ "$NGINX_BACKEND" != "200" ] || [ "$NGINX_FRONTEND" != "200" ]; then
              echo "‚ö†Ô∏è  Nginx proxy test returned non-200, but ports are listening"
              echo "Backend via Nginx: HTTP $NGINX_BACKEND"
              echo "Frontend via Nginx: HTTP $NGINX_FRONTEND"
              echo "PM2 status:"
              pm2 list || true
              echo "Nginx error log (last 10 lines):"
              sudo tail -10 /var/log/nginx/error.log || true
              echo "‚ö†Ô∏è  Services are running but Nginx may need more time or configuration"
            fi
            
            echo "=========================================="
            echo "‚úÖ DEPLOYMENT COMPLETE!"
            echo "=========================================="
            echo "üåê Application: http://${EC2_HOST}"
            echo "üìå Commit: $NEW_COMMIT"
            echo "‚úÖ Backend: Listening on port 3001"
            echo "‚úÖ Frontend: Listening on port 3000"
          ENDSSH

      - name: Verify deployment
        continue-on-error: true
        run: |
          sleep 30
          EC2_HOST="${{ secrets.EC2_HOST }}"
          echo "üîç Verifying deployment from GitHub Actions..."
          
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${EC2_HOST}/health" 2>&1 || echo "000")
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${EC2_HOST}/" 2>&1 || echo "000")
          
          echo "Backend health (via Nginx): HTTP $BACKEND_STATUS"
          echo "Frontend (via Nginx): HTTP $FRONTEND_STATUS"
          
          if [ "$BACKEND_STATUS" = "200" ] && [ "$FRONTEND_STATUS" = "200" ]; then
            echo "‚úÖ Deployment successful! Both services are responding."
          else
            echo "‚ö†Ô∏è  Services may still be starting or Nginx may need configuration"
            echo "Backend endpoint: http://${EC2_HOST}/health"
            echo "Frontend endpoint: http://${EC2_HOST}/"
            echo "API endpoint: http://${EC2_HOST}/api"
          fi
