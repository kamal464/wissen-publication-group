name: Deploy to AWS EC2

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy-to-ec2:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          printf '%s\n' "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          sed -i 's/\r$//' ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          if [ ! -s ~/.ssh/id_rsa ]; then
            echo "‚ùå SSH key file is empty"
            exit 1
          fi
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/id_rsa; then
            echo "‚ùå Invalid SSH key format"
            exit 1
          fi
          ssh-keyscan -H ${{ secrets.EC2_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 644 ~/.ssh/known_hosts

      - name: Deploy to EC2
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          EC2_HOST: ${{ secrets.EC2_HOST }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          S3_BUCKET_NAME: ${{ secrets.S3_BUCKET_NAME }}
          CLOUDFRONT_URL: ${{ secrets.CLOUDFRONT_URL }}
        run: |
          ssh -o StrictHostKeyChecking=no ubuntu@${EC2_HOST} bash -s << 'ENDSSH'
            export DB_PASSWORD="${DB_PASSWORD}"
            export EC2_HOST="${EC2_HOST}"
            export AWS_REGION="${AWS_REGION}"
            export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}"
            export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}"
            export S3_BUCKET_NAME="${S3_BUCKET_NAME}"
            export CLOUDFRONT_URL="${CLOUDFRONT_URL}"
            set -x
            cd /var/www/wissen-publication-group || { echo "‚ùå Directory not found"; exit 1; }
            
            echo "=========================================="
            echo "üöÄ STARTING DEPLOYMENT"
            echo "=========================================="
            
            pm2 delete all 2>/dev/null || true
            sleep 2
            
            echo "üì• Pulling latest code..."
            git fetch origin
            git reset --hard origin/main
            git clean -fd
            NEW_COMMIT=$(git rev-parse --short HEAD)
            echo "üìå Deployed commit: $NEW_COMMIT"
            
            # URL encode the password to handle special characters
            DB_PASSWORD_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('${DB_PASSWORD}', safe=''))" 2>/dev/null || echo "${DB_PASSWORD}")
            
            {
              echo "DATABASE_URL=postgresql://postgres:${DB_PASSWORD_ENCODED}@localhost:5432/wissen_publication_group"
              echo "NODE_ENV=production"
              echo "PORT=3001"
              echo "CORS_ORIGIN=http://${EC2_HOST},http://localhost:3000,http://localhost:3002"
              echo "AWS_REGION=${AWS_REGION}"
              echo "AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}"
              echo "AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}"
              echo "S3_BUCKET_NAME=${S3_BUCKET_NAME}"
              echo "CLOUDFRONT_URL=${CLOUDFRONT_URL}"
            } > backend/.env
            
            echo "‚úÖ Created backend/.env file"
            echo "üìù Verifying database connection string (password hidden)..."
            grep -v "PASSWORD" backend/.env | head -1 || true
            
            echo "NEXT_PUBLIC_API_URL=http://${EC2_HOST}/api" > frontend/.env.production
            export NEXT_PUBLIC_BUILD_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            echo "NEXT_PUBLIC_BUILD_TIME=$NEXT_PUBLIC_BUILD_TIME" >> frontend/.env.production
            
            echo "üî® Building backend..."
            cd backend
            npm ci
            npx prisma generate
            npx prisma db push --accept-data-loss || true
            rm -rf dist
            npm run build
            if [ ! -f "dist/src/main.js" ]; then
              echo "‚ùå Backend build failed"
              exit 1
            fi
            cd ..
            
            echo "üî® Building frontend..."
            cd frontend
            npm ci
            rm -rf .next node_modules/.cache .swc
            echo "üìù Building with API URL: http://${EC2_HOST}/api"
            NEXT_PUBLIC_API_URL="http://${EC2_HOST}/api" NEXT_PUBLIC_BUILD_TIME=$NEXT_PUBLIC_BUILD_TIME npm run build
            if [ ! -d ".next" ]; then
              echo "‚ùå Frontend build failed"
              exit 1
            fi
            cd ..
            
            echo "üöÄ Starting services..."
            mkdir -p logs
            pm2 delete all 2>/dev/null || true
            sleep 2
            
            cd backend
            pm2 start node --name wissen-backend -- dist/src/main.js || {
              echo "‚ùå Backend start failed"
              pm2 logs wissen-backend --lines 20 --nostream 2>/dev/null || true
              exit 1
            }
            cd ..
            
            cd frontend
            pm2 start npm --name wissen-frontend -- start || {
              echo "‚ùå Frontend start failed"
              pm2 logs wissen-frontend --lines 20 --nostream 2>/dev/null || true
              exit 1
            }
            cd ..
            
            pm2 save
            
            echo "‚è≥ Waiting for services to start..."
            sleep 30
            
            echo "üîç Verifying services..."
            pm2 ping || pm2 kill && pm2 resurrect || true
            sleep 2
            
            BACKEND_STATUS=$(pm2 list | grep wissen-backend | awk '{print $10}' || echo "unknown")
            FRONTEND_STATUS=$(pm2 list | grep wissen-frontend | awk '{print $10}' || echo "unknown")
            
            echo "Backend PM2 status: $BACKEND_STATUS"
            echo "Frontend PM2 status: $FRONTEND_STATUS"
            
            if [ "$BACKEND_STATUS" != "online" ] && [ "$BACKEND_STATUS" != "errored" ]; then
              echo "‚ö†Ô∏è  Backend PM2 status is $BACKEND_STATUS (checking if process is running...)"
              if pgrep -f "dist/src/main.js" > /dev/null; then
                echo "‚úÖ Backend process is running (PM2 status check may be unreliable)"
                BACKEND_STATUS="online"
              else
                echo "‚ùå Backend not running"
                pm2 logs wissen-backend --lines 30 --nostream || true
                exit 1
              fi
            fi
            
            if [ "$FRONTEND_STATUS" != "online" ] && [ "$FRONTEND_STATUS" != "errored" ]; then
              echo "‚ö†Ô∏è  Frontend PM2 status is $FRONTEND_STATUS (checking if process is running...)"
              if pgrep -f "npm.*start" > /dev/null || pgrep -f "next-server" > /dev/null; then
                echo "‚úÖ Frontend process is running (PM2 status check may be unreliable)"
                FRONTEND_STATUS="online"
              else
                echo "‚ùå Frontend not running"
                pm2 logs wissen-frontend --lines 30 --nostream || true
                exit 1
              fi
            fi
            
            BACKEND_PORT=$(netstat -tln 2>/dev/null | grep -c ":3001 " || echo "0")
            FRONTEND_PORT=$(netstat -tln 2>/dev/null | grep -c ":3000 " || echo "0")
            
            echo "Backend port check: $BACKEND_PORT"
            echo "Frontend port check: $FRONTEND_PORT"
            
            if [ "$BACKEND_PORT" -eq "0" ]; then
              echo "‚ùå Backend not listening on port 3001"
              pm2 logs wissen-backend --lines 30 --nostream
              exit 1
            fi
            
            if [ "$FRONTEND_PORT" -eq "0" ]; then
              echo "‚ùå Frontend not listening on port 3000"
              pm2 logs wissen-frontend --lines 30 --nostream
              exit 1
            fi
            
            echo "üîç Testing health endpoints (with retries)..."
            BACKEND_HEALTH="000"
            FRONTEND_HEALTH="000"
            
            for i in 1 2 3 4 5; do
              echo "Attempt $i/5: Checking backend health..."
              BACKEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/health 2>/dev/null || echo "000")
              if [ "$BACKEND_HEALTH" = "200" ]; then
                echo "‚úÖ Backend health check passed!"
                break
              fi
              sleep 5
            done
            
            for i in 1 2 3 4 5; do
              echo "Attempt $i/5: Checking frontend health..."
              FRONTEND_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null || echo "000")
              if [ "$FRONTEND_HEALTH" = "200" ]; then
                echo "‚úÖ Frontend health check passed!"
                break
              fi
              sleep 5
            done
            
            echo "Backend health: HTTP $BACKEND_HEALTH"
            echo "Frontend health: HTTP $FRONTEND_HEALTH"
            
            if [ "$BACKEND_HEALTH" != "200" ]; then
              echo "‚ö†Ô∏è  Backend health check returned $BACKEND_HEALTH (may still be starting)"
              echo "Backend logs:"
              pm2 logs wissen-backend --lines 20 --nostream || true
              echo "‚ö†Ô∏è  Continuing deployment - backend may need more time to start"
            fi
            
            if [ "$FRONTEND_HEALTH" != "200" ]; then
              echo "‚ö†Ô∏è  Frontend health check returned $FRONTEND_HEALTH (may still be starting)"
              echo "Frontend logs:"
              pm2 logs wissen-frontend --lines 20 --nostream || true
              echo "‚ö†Ô∏è  Continuing deployment - frontend may need more time to start"
            fi
            
            echo "üîç Verifying services are running before configuring Nginx..."
            echo "Waiting for services to be ready..."
            sleep 10
            
            # Wait for backend to be ready (max 60 seconds)
            BACKEND_READY=0
            for i in {1..12}; do
              BACKEND_RUNNING=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3001/health 2>/dev/null || echo "000")
              if [ "$BACKEND_RUNNING" = "200" ]; then
                echo "‚úÖ Backend is ready (HTTP $BACKEND_RUNNING)"
                BACKEND_READY=1
                break
              fi
              echo "   Attempt $i/12: Backend not ready yet (HTTP $BACKEND_RUNNING), waiting..."
              sleep 5
            done
            
            # Wait for frontend to be ready (max 60 seconds)
            FRONTEND_READY=0
            for i in {1..12}; do
              FRONTEND_RUNNING=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000 2>/dev/null || echo "000")
              if [ "$FRONTEND_RUNNING" = "200" ]; then
                echo "‚úÖ Frontend is ready (HTTP $FRONTEND_RUNNING)"
                FRONTEND_READY=1
                break
              fi
              echo "   Attempt $i/12: Frontend not ready yet (HTTP $FRONTEND_RUNNING), waiting..."
              sleep 5
            done
            
            if [ "$BACKEND_READY" -eq 0 ]; then
              echo "‚ùå Backend failed to start after 60 seconds"
              echo "PM2 status:"
              pm2 list || true
              echo "Backend logs:"
              pm2 logs wissen-backend --lines 30 --nostream || true
              echo "Checking if port 3001 is listening:"
              netstat -tln | grep ":3001" || echo "Port 3001 not listening"
              echo "‚ö†Ô∏è  Continuing anyway - backend may start later"
            fi
            
            if [ "$FRONTEND_READY" -eq 0 ]; then
              echo "‚ùå Frontend failed to start after 60 seconds"
              echo "Frontend logs:"
              pm2 logs wissen-frontend --lines 30 --nostream || true
              echo "Checking if port 3000 is listening:"
              netstat -tln | grep ":3000" || echo "Port 3000 not listening"
              echo "‚ö†Ô∏è  Continuing anyway - frontend may start later"
            fi
            
            echo "üîß Configuring Nginx..."
            # Copy the nginx config file from the repo
            if [ -f "nginx-production.conf" ]; then
              sudo cp nginx-production.conf /etc/nginx/sites-available/wissen-publication-group
              echo "‚úÖ Copied nginx-production.conf"
            else
              echo "‚ö†Ô∏è  nginx-production.conf not found, using fallback method"
              # Fallback: use the existing nginx-wissen.conf if available
              if [ -f "nginx-wissen.conf" ]; then
                sudo cp nginx-wissen.conf /etc/nginx/sites-available/wissen-publication-group
                sudo sed -i 's/YOUR_EC2_IP/_/g' /etc/nginx/sites-available/wissen-publication-group
                sudo sed -i 's/api.yourdomain.com/_/g' /etc/nginx/sites-available/wissen-publication-group
                sudo sed -i 's/yourdomain.com/_/g' /etc/nginx/sites-available/wissen-publication-group
                sudo sed -i 's/www.yourdomain.com/_/g' /etc/nginx/sites-available/wissen-publication-group
              else
                echo "‚ùå No nginx config file found!"
                exit 1
              fi
            fi
            
            sudo ln -sf /etc/nginx/sites-available/wissen-publication-group /etc/nginx/sites-enabled/
            sudo rm -f /etc/nginx/sites-enabled/default
            
            if sudo nginx -t; then
              sudo systemctl reload nginx || sudo systemctl restart nginx
              echo "‚úÖ Nginx configured and reloaded"
              echo "Nginx status:"
              sudo systemctl status nginx --no-pager | head -5 || true
            else
              echo "‚ùå Nginx configuration test failed"
              sudo nginx -t
              echo "Nginx error log (last 10 lines):"
              sudo tail -10 /var/log/nginx/error.log || true
              exit 1
            fi
            
            echo "üîç Final verification - testing Nginx proxy..."
            sleep 3
            NGINX_BACKEND=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/health 2>/dev/null || echo "000")
            NGINX_FRONTEND=$(curl -s -o /dev/null -w "%{http_code}" http://localhost/ 2>/dev/null || echo "000")
            echo "Nginx proxy to backend (/health): HTTP $NGINX_BACKEND"
            echo "Nginx proxy to frontend (/): HTTP $NGINX_FRONTEND"
            
            if [ "$NGINX_BACKEND" != "200" ] || [ "$NGINX_FRONTEND" != "200" ]; then
              echo "‚ö†Ô∏è  Nginx proxy test failed - services may need more time to start"
              echo "PM2 status:"
              pm2 list || true
              echo "Nginx error log:"
              sudo tail -20 /var/log/nginx/error.log || true
            fi
            
            echo "=========================================="
            echo "‚úÖ DEPLOYMENT COMPLETE!"
            echo "=========================================="
            echo "üåê Application: http://${EC2_HOST}"
            echo "üìå Commit: $NEW_COMMIT"
          ENDSSH

      - name: Verify deployment
        continue-on-error: true
        run: |
          sleep 30
          EC2_HOST="${{ secrets.EC2_HOST }}"
          echo "üîç Verifying deployment from GitHub Actions..."
          
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${EC2_HOST}/health" 2>&1 || echo "000")
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "http://${EC2_HOST}/" 2>&1 || echo "000")
          
          echo "Backend health (via Nginx): HTTP $BACKEND_STATUS"
          echo "Frontend (via Nginx): HTTP $FRONTEND_STATUS"
          
          if [ "$BACKEND_STATUS" = "200" ] && [ "$FRONTEND_STATUS" = "200" ]; then
            echo "‚úÖ Deployment successful! Both services are responding."
          else
            echo "‚ö†Ô∏è  Services may still be starting or Nginx may need configuration"
            echo "Backend endpoint: http://${EC2_HOST}/health"
            echo "Frontend endpoint: http://${EC2_HOST}/"
            echo "API endpoint: http://${EC2_HOST}/api"
          fi
